<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>ONL_testbed.yml_07_31_2022_14:07:25.html</h1>
    <p>Report generated on 31-Jul-2022 at 14:07:33 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "py": "1.11.0", "pytest": "7.0.1"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Linux-5.4.0-122-generic-x86_64-with-Ubuntu-18.04-bionic</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"allure-pytest": "2.9.45", "html": "3.1.1", "metadata": "1.11.0"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.6.9</td></tr></table>
    <h2>Summary</h2>
    <p>3 tests ran in 7.57 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">3 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">test_19.py::test_CheckPSUState[testbed]</td>
          <td class="col-duration">2.40</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;ssh_login.Login object at 0x7f5cb74010f0&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>&gt;           self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/><br/>../Lib/ssh_login.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb7401198&gt;<br/>hostname = &#x27;192.168.1.7&#x27;, port = 22, username = &#x27;root&#x27;, password = &#x27;onl&#x27;<br/>pkey = None, key_filename = None, timeout = None, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=11, family=AddressFamily.AF_INET, type=2049, proto=0, laddr=(&#x27;172.22.92.133&#x27;, 35088), raddr=(&#x27;192.168.1.7&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None<br/>banner_timeout = None, auth_timeout = None, gss_trust_dns = True<br/>passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>                    retry_on_signal(lambda: sock.connect(addr))<br/>                    # Break out of the loop on success<br/>                    break<br/>                except socket.error as e:<br/>                    # Raise anything that isn&#x27;t a straight up connection error<br/>                    # (such as a resolution error)<br/>                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):<br/>                        raise<br/>                    # Capture anything else so we know how the run looks once<br/>                    # iteration is complete. Retain info about which attempt<br/>                    # this was.<br/>                    errors[addr] = e<br/>    <br/>            # Make sure we explode usefully if no address family attempts<br/>            # succeeded. We&#x27;ve no way of knowing which error is the &quot;right&quot;<br/>            # one, so we construct a hybrid exception containing all the real<br/>            # ones, of a subclass that client code should still be watching for<br/>            # (socket.error)<br/>            if len(errors) == len(to_try):<br/>                raise NoValidConnectionsError(errors)<br/>    <br/>        t = self._transport = Transport(<br/>            sock,<br/>            gss_kex=gss_kex,<br/>            gss_deleg_creds=gss_deleg_creds,<br/>            disabled_algorithms=disabled_algorithms,<br/>        )<br/>        t.use_compression(compress=compress)<br/>        t.set_gss_host(<br/>            # t.hostname may be None, but GSS-API requires a target name.<br/>            # Therefore use hostname as fallback.<br/>            gss_host=gss_host or hostname,<br/>            trust_dns=gss_trust_dns,<br/>            gssapi_requested=gss_auth or gss_kex,<br/>        )<br/>        if self._log_channel is not None:<br/>            t.set_log_channel(self._log_channel)<br/>        if banner_timeout is not None:<br/>            t.banner_timeout = banner_timeout<br/>        if auth_timeout is not None:<br/>            t.auth_timeout = auth_timeout<br/>    <br/>        if port == SSH_PORT:<br/>            server_hostkey_name = hostname<br/>        else:<br/>            server_hostkey_name = &quot;[{}]:{}&quot;.format(hostname, port)<br/>        our_server_keys = None<br/>    <br/>        our_server_keys = self._system_host_keys.get(server_hostkey_name)<br/>        if our_server_keys is None:<br/>            our_server_keys = self._host_keys.get(server_hostkey_name)<br/>        if our_server_keys is not None:<br/>            keytype = our_server_keys.keys()[0]<br/>            sec_opts = t.get_security_options()<br/>            other_types = [x for x in sec_opts.key_types if x != keytype]<br/>            sec_opts.key_types = [keytype] + other_types<br/>    <br/>        t.start_client(timeout=timeout)<br/>    <br/>        # If GSS-API Key Exchange is performed we are not required to check the<br/>        # host key, because the host is authenticated via GSS-API / SSPI as<br/>        # well as our client.<br/>        if not self._transport.gss_kex_used:<br/>            server_key = t.get_remote_server_key()<br/>            if our_server_keys is None:<br/>                # will raise exception if the key is rejected<br/>                self._policy.missing_host_key(<br/>                    self, server_hostkey_name, server_key<br/>                )<br/>            else:<br/>                our_key = our_server_keys.get(server_key.get_name())<br/>                if our_key != server_key:<br/>                    if our_key is None:<br/>                        our_key = list(our_server_keys.values())[0]<br/>                    raise BadHostKeyException(hostname, server_key, our_key)<br/>    <br/>        if username is None:<br/>            username = getpass.getuser()<br/>    <br/>        if key_filename is None:<br/>            key_filenames = []<br/>        elif isinstance(key_filename, string_types):<br/>            key_filenames = [key_filename]<br/>        else:<br/>            key_filenames = key_filename<br/>    <br/>        self._auth(<br/>            username,<br/>            password,<br/>            pkey,<br/>            key_filenames,<br/>            allow_agent,<br/>            look_for_keys,<br/>            gss_auth,<br/>            gss_kex,<br/>            gss_deleg_creds,<br/>            t.gss_host,<br/>&gt;           passphrase,<br/>        )<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:446: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb7401198&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>                self._transport.auth_password(username, password)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>        elif two_factor:<br/>            try:<br/>                self._transport.auth_interactive_dumb(username)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        # if we got an auth-failed exception earlier, re-raise it<br/>        if saved_exception is not None:<br/>&gt;           raise saved_exception<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:766: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb7401198&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>&gt;               self._transport.auth_password(username, password)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:753: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.Transport at 0xb74013c8 (cipher aes128-ctr, 128 bits) (connected; awaiting auth)&gt;<br/>username = &#x27;root&#x27;, password = &#x27;onl&#x27;, event = None, fallback = True<br/><br/>    def auth_password(self, username, password, event=None, fallback=True):<br/>        &quot;&quot;&quot;<br/>        Authenticate to the server using a password.  The username and password<br/>        are sent over an encrypted link.<br/>    <br/>        If an ``event`` is passed in, this method will return immediately, and<br/>        the event will be triggered once authentication succeeds or fails.  On<br/>        success, `is_authenticated` will return ``True``.  On failure, you may<br/>        use `get_exception` to get more detailed error information.<br/>    <br/>        Since 1.1, if no event is passed, this method will block until the<br/>        authentication succeeds or fails.  On failure, an exception is raised.<br/>        Otherwise, the method simply returns.<br/>    <br/>        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the<br/>        default), if the server doesn&#x27;t support plain password authentication<br/>        but does support so-called &quot;keyboard-interactive&quot; mode, an attempt<br/>        will be made to authenticate using this interactive mode.  If it fails,<br/>        the normal exception will be thrown as if the attempt had never been<br/>        made.  This is useful for some recent Gentoo and Debian distributions,<br/>        which turn off plain password authentication in a misguided belief<br/>        that interactive authentication is &quot;more secure&quot;.  (It&#x27;s not.)<br/>    <br/>        If the server requires multi-step authentication (which is very rare),<br/>        this method will return a list of auth types permissible for the next<br/>        step.  Otherwise, in the normal case, an empty list is returned.<br/>    <br/>        :param str username: the username to authenticate as<br/>        :param basestring password: the password to authenticate with<br/>        :param .threading.Event event:<br/>            an event to trigger when the authentication attempt is complete<br/>            (whether it was successful or not)<br/>        :param bool fallback:<br/>            ``True`` if an attempt at an automated &quot;interactive&quot; password auth<br/>            should be made if the server doesn&#x27;t support normal password auth<br/>        :return:<br/>            list of auth types permissible for the next stage of<br/>            authentication (normally empty)<br/>    <br/>        :raises:<br/>            `.BadAuthenticationType` -- if password authentication isn&#x27;t<br/>            allowed by the server for this user (and no event was passed in)<br/>        :raises:<br/>            `.AuthenticationException` -- if the authentication failed (and no<br/>            event was passed in)<br/>        :raises: `.SSHException` -- if there was a network error<br/>        &quot;&quot;&quot;<br/>        if (not self.active) or (not self.initial_kex_done):<br/>            # we should never try to send the password unless we&#x27;re on a secure<br/>            # link<br/>            raise SSHException(&quot;No existing session&quot;)<br/>        if event is None:<br/>            my_event = threading.Event()<br/>        else:<br/>            my_event = event<br/>        self.auth_handler = AuthHandler(self)<br/>        self.auth_handler.auth_password(username, password, my_event)<br/>        if event is not None:<br/>            # caller wants to wait for event themselves<br/>            return []<br/>        try:<br/>&gt;           return self.auth_handler.wait_for_response(my_event)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/transport.py:1564: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.auth_handler.AuthHandler object at 0x7f5cb73ae630&gt;<br/>event = &lt;threading.Event object at 0x7f5cb73ae5f8&gt;<br/><br/>    def wait_for_response(self, event):<br/>        max_ts = None<br/>        if self.transport.auth_timeout is not None:<br/>            max_ts = time.time() + self.transport.auth_timeout<br/>        while True:<br/>            event.wait(0.1)<br/>            if not self.transport.is_active():<br/>                e = self.transport.get_exception()<br/>                if (e is None) or issubclass(e.__class__, EOFError):<br/>                    e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>                raise e<br/>            if event.is_set():<br/>                break<br/>            if max_ts is not None and max_ts &lt;= time.time():<br/>                raise AuthenticationException(&quot;Authentication timeout.&quot;)<br/>    <br/>        if not self.is_authenticated():<br/>            e = self.transport.get_exception()<br/>            if e is None:<br/>                e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>            # this is horrible.  Python Exception isn&#x27;t yet descended from<br/>            # object, so type(e) won&#x27;t work. :(<br/>            if issubclass(e.__class__, PartialAuthentication):<br/>                return e.allowed_types<br/>&gt;           raise e<br/><span class="error">E           paramiko.ssh_exception.AuthenticationException: Authentication failed.</span><br/><br/>../../.local/lib/python3.6/site-packages/paramiko/auth_handler.py:259: AuthenticationException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>test_importlib = &lt;module &#x27;testbed&#x27; from &#x27;/home/alexander/ONLP_Automation/tmp/testbed.py&#x27;&gt;<br/><br/>    @pytest.mark.All<br/>    @pytest.mark.Sanity<br/>    def test_CheckPSUState(test_importlib):<br/>    <br/>        DUTInfo = test_importlib<br/>&gt;       val = Get_PSU_Value(DUTInfo.DUT1_IP, 1, &#x27;State&#x27;)<br/><br/>../Scripts/test_19.py:33: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>../Lib/GetKeyValue.py:29: in Get_PSU_Value<br/>    DUT = Login(IPAddress, &#x27;root&#x27;, &#x27;onl&#x27;)<br/>../Lib/ssh_login.py:10: in __init__<br/>    self.__deviceConnect()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ssh_login.Login object at 0x7f5cb74010f0&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>            self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/>&gt;       except AuthenticationException as err:<br/><span class="error">E       NameError: name &#x27;AuthenticationException&#x27; is not defined</span><br/><br/>../Lib/ssh_login.py:18: NameError<br/> -----------------------------Captured stdout setup------------------------------ <br/>&lt;module &#x27;testbed&#x27; from &#x27;/home/alexander/ONLP_Automation/tmp/testbed.py&#x27;&gt;
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">test_20.py::test_CheckPSUStatus[testbed]</td>
          <td class="col-duration">2.40</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;ssh_login.Login object at 0x7f5cb6291a58&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>&gt;           self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/><br/>../Lib/ssh_login.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb6291b38&gt;<br/>hostname = &#x27;192.168.1.7&#x27;, port = 22, username = &#x27;root&#x27;, password = &#x27;onl&#x27;<br/>pkey = None, key_filename = None, timeout = None, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=12, family=AddressFamily.AF_INET, type=2049, proto=0, laddr=(&#x27;172.22.92.133&#x27;, 35090), raddr=(&#x27;192.168.1.7&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None<br/>banner_timeout = None, auth_timeout = None, gss_trust_dns = True<br/>passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>                    retry_on_signal(lambda: sock.connect(addr))<br/>                    # Break out of the loop on success<br/>                    break<br/>                except socket.error as e:<br/>                    # Raise anything that isn&#x27;t a straight up connection error<br/>                    # (such as a resolution error)<br/>                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):<br/>                        raise<br/>                    # Capture anything else so we know how the run looks once<br/>                    # iteration is complete. Retain info about which attempt<br/>                    # this was.<br/>                    errors[addr] = e<br/>    <br/>            # Make sure we explode usefully if no address family attempts<br/>            # succeeded. We&#x27;ve no way of knowing which error is the &quot;right&quot;<br/>            # one, so we construct a hybrid exception containing all the real<br/>            # ones, of a subclass that client code should still be watching for<br/>            # (socket.error)<br/>            if len(errors) == len(to_try):<br/>                raise NoValidConnectionsError(errors)<br/>    <br/>        t = self._transport = Transport(<br/>            sock,<br/>            gss_kex=gss_kex,<br/>            gss_deleg_creds=gss_deleg_creds,<br/>            disabled_algorithms=disabled_algorithms,<br/>        )<br/>        t.use_compression(compress=compress)<br/>        t.set_gss_host(<br/>            # t.hostname may be None, but GSS-API requires a target name.<br/>            # Therefore use hostname as fallback.<br/>            gss_host=gss_host or hostname,<br/>            trust_dns=gss_trust_dns,<br/>            gssapi_requested=gss_auth or gss_kex,<br/>        )<br/>        if self._log_channel is not None:<br/>            t.set_log_channel(self._log_channel)<br/>        if banner_timeout is not None:<br/>            t.banner_timeout = banner_timeout<br/>        if auth_timeout is not None:<br/>            t.auth_timeout = auth_timeout<br/>    <br/>        if port == SSH_PORT:<br/>            server_hostkey_name = hostname<br/>        else:<br/>            server_hostkey_name = &quot;[{}]:{}&quot;.format(hostname, port)<br/>        our_server_keys = None<br/>    <br/>        our_server_keys = self._system_host_keys.get(server_hostkey_name)<br/>        if our_server_keys is None:<br/>            our_server_keys = self._host_keys.get(server_hostkey_name)<br/>        if our_server_keys is not None:<br/>            keytype = our_server_keys.keys()[0]<br/>            sec_opts = t.get_security_options()<br/>            other_types = [x for x in sec_opts.key_types if x != keytype]<br/>            sec_opts.key_types = [keytype] + other_types<br/>    <br/>        t.start_client(timeout=timeout)<br/>    <br/>        # If GSS-API Key Exchange is performed we are not required to check the<br/>        # host key, because the host is authenticated via GSS-API / SSPI as<br/>        # well as our client.<br/>        if not self._transport.gss_kex_used:<br/>            server_key = t.get_remote_server_key()<br/>            if our_server_keys is None:<br/>                # will raise exception if the key is rejected<br/>                self._policy.missing_host_key(<br/>                    self, server_hostkey_name, server_key<br/>                )<br/>            else:<br/>                our_key = our_server_keys.get(server_key.get_name())<br/>                if our_key != server_key:<br/>                    if our_key is None:<br/>                        our_key = list(our_server_keys.values())[0]<br/>                    raise BadHostKeyException(hostname, server_key, our_key)<br/>    <br/>        if username is None:<br/>            username = getpass.getuser()<br/>    <br/>        if key_filename is None:<br/>            key_filenames = []<br/>        elif isinstance(key_filename, string_types):<br/>            key_filenames = [key_filename]<br/>        else:<br/>            key_filenames = key_filename<br/>    <br/>        self._auth(<br/>            username,<br/>            password,<br/>            pkey,<br/>            key_filenames,<br/>            allow_agent,<br/>            look_for_keys,<br/>            gss_auth,<br/>            gss_kex,<br/>            gss_deleg_creds,<br/>            t.gss_host,<br/>&gt;           passphrase,<br/>        )<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:446: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb6291b38&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>                self._transport.auth_password(username, password)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>        elif two_factor:<br/>            try:<br/>                self._transport.auth_interactive_dumb(username)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        # if we got an auth-failed exception earlier, re-raise it<br/>        if saved_exception is not None:<br/>&gt;           raise saved_exception<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:766: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb6291b38&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>&gt;               self._transport.auth_password(username, password)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:753: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.Transport at 0xb6291ba8 (cipher aes128-ctr, 128 bits) (connected; awaiting auth)&gt;<br/>username = &#x27;root&#x27;, password = &#x27;onl&#x27;, event = None, fallback = True<br/><br/>    def auth_password(self, username, password, event=None, fallback=True):<br/>        &quot;&quot;&quot;<br/>        Authenticate to the server using a password.  The username and password<br/>        are sent over an encrypted link.<br/>    <br/>        If an ``event`` is passed in, this method will return immediately, and<br/>        the event will be triggered once authentication succeeds or fails.  On<br/>        success, `is_authenticated` will return ``True``.  On failure, you may<br/>        use `get_exception` to get more detailed error information.<br/>    <br/>        Since 1.1, if no event is passed, this method will block until the<br/>        authentication succeeds or fails.  On failure, an exception is raised.<br/>        Otherwise, the method simply returns.<br/>    <br/>        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the<br/>        default), if the server doesn&#x27;t support plain password authentication<br/>        but does support so-called &quot;keyboard-interactive&quot; mode, an attempt<br/>        will be made to authenticate using this interactive mode.  If it fails,<br/>        the normal exception will be thrown as if the attempt had never been<br/>        made.  This is useful for some recent Gentoo and Debian distributions,<br/>        which turn off plain password authentication in a misguided belief<br/>        that interactive authentication is &quot;more secure&quot;.  (It&#x27;s not.)<br/>    <br/>        If the server requires multi-step authentication (which is very rare),<br/>        this method will return a list of auth types permissible for the next<br/>        step.  Otherwise, in the normal case, an empty list is returned.<br/>    <br/>        :param str username: the username to authenticate as<br/>        :param basestring password: the password to authenticate with<br/>        :param .threading.Event event:<br/>            an event to trigger when the authentication attempt is complete<br/>            (whether it was successful or not)<br/>        :param bool fallback:<br/>            ``True`` if an attempt at an automated &quot;interactive&quot; password auth<br/>            should be made if the server doesn&#x27;t support normal password auth<br/>        :return:<br/>            list of auth types permissible for the next stage of<br/>            authentication (normally empty)<br/>    <br/>        :raises:<br/>            `.BadAuthenticationType` -- if password authentication isn&#x27;t<br/>            allowed by the server for this user (and no event was passed in)<br/>        :raises:<br/>            `.AuthenticationException` -- if the authentication failed (and no<br/>            event was passed in)<br/>        :raises: `.SSHException` -- if there was a network error<br/>        &quot;&quot;&quot;<br/>        if (not self.active) or (not self.initial_kex_done):<br/>            # we should never try to send the password unless we&#x27;re on a secure<br/>            # link<br/>            raise SSHException(&quot;No existing session&quot;)<br/>        if event is None:<br/>            my_event = threading.Event()<br/>        else:<br/>            my_event = event<br/>        self.auth_handler = AuthHandler(self)<br/>        self.auth_handler.auth_password(username, password, my_event)<br/>        if event is not None:<br/>            # caller wants to wait for event themselves<br/>            return []<br/>        try:<br/>&gt;           return self.auth_handler.wait_for_response(my_event)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/transport.py:1564: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.auth_handler.AuthHandler object at 0x7f5cb630bb70&gt;<br/>event = &lt;threading.Event object at 0x7f5cb630b588&gt;<br/><br/>    def wait_for_response(self, event):<br/>        max_ts = None<br/>        if self.transport.auth_timeout is not None:<br/>            max_ts = time.time() + self.transport.auth_timeout<br/>        while True:<br/>            event.wait(0.1)<br/>            if not self.transport.is_active():<br/>                e = self.transport.get_exception()<br/>                if (e is None) or issubclass(e.__class__, EOFError):<br/>                    e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>                raise e<br/>            if event.is_set():<br/>                break<br/>            if max_ts is not None and max_ts &lt;= time.time():<br/>                raise AuthenticationException(&quot;Authentication timeout.&quot;)<br/>    <br/>        if not self.is_authenticated():<br/>            e = self.transport.get_exception()<br/>            if e is None:<br/>                e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>            # this is horrible.  Python Exception isn&#x27;t yet descended from<br/>            # object, so type(e) won&#x27;t work. :(<br/>            if issubclass(e.__class__, PartialAuthentication):<br/>                return e.allowed_types<br/>&gt;           raise e<br/><span class="error">E           paramiko.ssh_exception.AuthenticationException: Authentication failed.</span><br/><br/>../../.local/lib/python3.6/site-packages/paramiko/auth_handler.py:259: AuthenticationException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>test_importlib = &lt;module &#x27;testbed&#x27; from &#x27;/home/alexander/ONLP_Automation/tmp/testbed.py&#x27;&gt;<br/><br/>    @pytest.mark.All<br/>    @pytest.mark.Sanity<br/>    def test_CheckPSUStatus(test_importlib):<br/>    <br/>        DUTInfo = test_importlib<br/>&gt;       val = Get_PSU_Value(DUTInfo.DUT1_IP, 1, &#x27;Status&#x27;)<br/><br/>../Scripts/test_20.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>../Lib/GetKeyValue.py:29: in Get_PSU_Value<br/>    DUT = Login(IPAddress, &#x27;root&#x27;, &#x27;onl&#x27;)<br/>../Lib/ssh_login.py:10: in __init__<br/>    self.__deviceConnect()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ssh_login.Login object at 0x7f5cb6291a58&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>            self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/>&gt;       except AuthenticationException as err:<br/><span class="error">E       NameError: name &#x27;AuthenticationException&#x27; is not defined</span><br/><br/>../Lib/ssh_login.py:18: NameError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">test_22.py::test_CheckPSUType[testbed]</td>
          <td class="col-duration">2.39</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;ssh_login.Login object at 0x7f5cb621d320&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>&gt;           self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/><br/>../Lib/ssh_login.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb621d5c0&gt;<br/>hostname = &#x27;192.168.1.7&#x27;, port = 22, username = &#x27;root&#x27;, password = &#x27;onl&#x27;<br/>pkey = None, key_filename = None, timeout = None, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=13, family=AddressFamily.AF_INET, type=2049, proto=0, laddr=(&#x27;172.22.92.133&#x27;, 35092), raddr=(&#x27;192.168.1.7&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None<br/>banner_timeout = None, auth_timeout = None, gss_trust_dns = True<br/>passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>                    retry_on_signal(lambda: sock.connect(addr))<br/>                    # Break out of the loop on success<br/>                    break<br/>                except socket.error as e:<br/>                    # Raise anything that isn&#x27;t a straight up connection error<br/>                    # (such as a resolution error)<br/>                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):<br/>                        raise<br/>                    # Capture anything else so we know how the run looks once<br/>                    # iteration is complete. Retain info about which attempt<br/>                    # this was.<br/>                    errors[addr] = e<br/>    <br/>            # Make sure we explode usefully if no address family attempts<br/>            # succeeded. We&#x27;ve no way of knowing which error is the &quot;right&quot;<br/>            # one, so we construct a hybrid exception containing all the real<br/>            # ones, of a subclass that client code should still be watching for<br/>            # (socket.error)<br/>            if len(errors) == len(to_try):<br/>                raise NoValidConnectionsError(errors)<br/>    <br/>        t = self._transport = Transport(<br/>            sock,<br/>            gss_kex=gss_kex,<br/>            gss_deleg_creds=gss_deleg_creds,<br/>            disabled_algorithms=disabled_algorithms,<br/>        )<br/>        t.use_compression(compress=compress)<br/>        t.set_gss_host(<br/>            # t.hostname may be None, but GSS-API requires a target name.<br/>            # Therefore use hostname as fallback.<br/>            gss_host=gss_host or hostname,<br/>            trust_dns=gss_trust_dns,<br/>            gssapi_requested=gss_auth or gss_kex,<br/>        )<br/>        if self._log_channel is not None:<br/>            t.set_log_channel(self._log_channel)<br/>        if banner_timeout is not None:<br/>            t.banner_timeout = banner_timeout<br/>        if auth_timeout is not None:<br/>            t.auth_timeout = auth_timeout<br/>    <br/>        if port == SSH_PORT:<br/>            server_hostkey_name = hostname<br/>        else:<br/>            server_hostkey_name = &quot;[{}]:{}&quot;.format(hostname, port)<br/>        our_server_keys = None<br/>    <br/>        our_server_keys = self._system_host_keys.get(server_hostkey_name)<br/>        if our_server_keys is None:<br/>            our_server_keys = self._host_keys.get(server_hostkey_name)<br/>        if our_server_keys is not None:<br/>            keytype = our_server_keys.keys()[0]<br/>            sec_opts = t.get_security_options()<br/>            other_types = [x for x in sec_opts.key_types if x != keytype]<br/>            sec_opts.key_types = [keytype] + other_types<br/>    <br/>        t.start_client(timeout=timeout)<br/>    <br/>        # If GSS-API Key Exchange is performed we are not required to check the<br/>        # host key, because the host is authenticated via GSS-API / SSPI as<br/>        # well as our client.<br/>        if not self._transport.gss_kex_used:<br/>            server_key = t.get_remote_server_key()<br/>            if our_server_keys is None:<br/>                # will raise exception if the key is rejected<br/>                self._policy.missing_host_key(<br/>                    self, server_hostkey_name, server_key<br/>                )<br/>            else:<br/>                our_key = our_server_keys.get(server_key.get_name())<br/>                if our_key != server_key:<br/>                    if our_key is None:<br/>                        our_key = list(our_server_keys.values())[0]<br/>                    raise BadHostKeyException(hostname, server_key, our_key)<br/>    <br/>        if username is None:<br/>            username = getpass.getuser()<br/>    <br/>        if key_filename is None:<br/>            key_filenames = []<br/>        elif isinstance(key_filename, string_types):<br/>            key_filenames = [key_filename]<br/>        else:<br/>            key_filenames = key_filename<br/>    <br/>        self._auth(<br/>            username,<br/>            password,<br/>            pkey,<br/>            key_filenames,<br/>            allow_agent,<br/>            look_for_keys,<br/>            gss_auth,<br/>            gss_kex,<br/>            gss_deleg_creds,<br/>            t.gss_host,<br/>&gt;           passphrase,<br/>        )<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:446: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb621d5c0&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>                self._transport.auth_password(username, password)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>        elif two_factor:<br/>            try:<br/>                self._transport.auth_interactive_dumb(username)<br/>                return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        # if we got an auth-failed exception earlier, re-raise it<br/>        if saved_exception is not None:<br/>&gt;           raise saved_exception<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:766: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x7f5cb621d5c0&gt;, username = &#x27;root&#x27;<br/>password = &#x27;onl&#x27;, pkey = None, key_filenames = [], allow_agent = False<br/>look_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True<br/>gss_host = None, passphrase = &#x27;onl&#x27;<br/><br/>    def _auth(<br/>        self,<br/>        username,<br/>        password,<br/>        pkey,<br/>        key_filenames,<br/>        allow_agent,<br/>        look_for_keys,<br/>        gss_auth,<br/>        gss_kex,<br/>        gss_deleg_creds,<br/>        gss_host,<br/>        passphrase,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Try, in order:<br/>    <br/>            - The key(s) passed in, if one was passed in.<br/>            - Any key we can find through an SSH agent (if allowed).<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in ~/.ssh/<br/>              (if allowed).<br/>            - Plain username/password auth, if a password was given.<br/>    <br/>        (The password might be needed to unlock a private key [if &#x27;passphrase&#x27;<br/>        isn&#x27;t also given], or for two-factor authentication [for which it is<br/>        required].)<br/>        &quot;&quot;&quot;<br/>        saved_exception = None<br/>        two_factor = False<br/>        allowed_types = set()<br/>        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}<br/>        if passphrase is None and password is not None:<br/>            passphrase = password<br/>    <br/>        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt<br/>        # authentication with gssapi-keyex.<br/>        if gss_kex and self._transport.gss_kex_used:<br/>            try:<br/>                self._transport.auth_gssapi_keyex(username)<br/>                return<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key<br/>        # Exchange is not performed, because if we use GSS-API for the key<br/>        # exchange, there is already a fully established GSS-API context, so<br/>        # why should we do that again?<br/>        if gss_auth:<br/>            try:<br/>                return self._transport.auth_gssapi_with_mic(<br/>                    username, gss_host, gss_deleg_creds<br/>                )<br/>            except Exception as e:<br/>                saved_exception = e<br/>    <br/>        if pkey is not None:<br/>            try:<br/>                self._log(<br/>                    DEBUG,<br/>                    &quot;Trying SSH key {}&quot;.format(<br/>                        hexlify(pkey.get_fingerprint())<br/>                    ),<br/>                )<br/>                allowed_types = set(<br/>                    self._transport.auth_publickey(username, pkey)<br/>                )<br/>                two_factor = allowed_types &amp; two_factor_types<br/>                if not two_factor:<br/>                    return<br/>            except SSHException as e:<br/>                saved_exception = e<br/>    <br/>        if not two_factor:<br/>            for key_filename in key_filenames:<br/>                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):<br/>                    try:<br/>                        key = self._key_from_filepath(<br/>                            key_filename, pkey_class, passphrase<br/>                        )<br/>                        allowed_types = set(<br/>                            self._transport.auth_publickey(username, key)<br/>                        )<br/>                        two_factor = allowed_types &amp; two_factor_types<br/>                        if not two_factor:<br/>                            return<br/>                        break<br/>                    except SSHException as e:<br/>                        saved_exception = e<br/>    <br/>        if not two_factor and allow_agent:<br/>            if self._agent is None:<br/>                self._agent = Agent()<br/>    <br/>            for key in self._agent.get_keys():<br/>                try:<br/>                    id_ = hexlify(key.get_fingerprint())<br/>                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))<br/>                    # for 2-factor auth a successfully auth&#x27;d key password<br/>                    # will return an allowed 2fac auth method<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except SSHException as e:<br/>                    saved_exception = e<br/>    <br/>        if not two_factor:<br/>            keyfiles = []<br/>    <br/>            for keytype, name in [<br/>                (RSAKey, &quot;rsa&quot;),<br/>                (DSSKey, &quot;dsa&quot;),<br/>                (ECDSAKey, &quot;ecdsa&quot;),<br/>                (Ed25519Key, &quot;ed25519&quot;),<br/>            ]:<br/>                # ~/ssh/ is for windows<br/>                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:<br/>                    full_path = os.path.expanduser(<br/>                        &quot;~/{}/id_{}&quot;.format(directory, name)<br/>                    )<br/>                    if os.path.isfile(full_path):<br/>                        # TODO: only do this append if below did not run<br/>                        keyfiles.append((keytype, full_path))<br/>                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):<br/>                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))<br/>    <br/>            if not look_for_keys:<br/>                keyfiles = []<br/>    <br/>            for pkey_class, filename in keyfiles:<br/>                try:<br/>                    key = self._key_from_filepath(<br/>                        filename, pkey_class, passphrase<br/>                    )<br/>                    # for 2-factor auth a successfully auth&#x27;d key will result<br/>                    # in [&#x27;password&#x27;]<br/>                    allowed_types = set(<br/>                        self._transport.auth_publickey(username, key)<br/>                    )<br/>                    two_factor = allowed_types &amp; two_factor_types<br/>                    if not two_factor:<br/>                        return<br/>                    break<br/>                except (SSHException, IOError) as e:<br/>                    saved_exception = e<br/>    <br/>        if password is not None:<br/>            try:<br/>&gt;               self._transport.auth_password(username, password)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/client.py:753: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.Transport at 0xb621d6d8 (cipher aes128-ctr, 128 bits) (connected; awaiting auth)&gt;<br/>username = &#x27;root&#x27;, password = &#x27;onl&#x27;, event = None, fallback = True<br/><br/>    def auth_password(self, username, password, event=None, fallback=True):<br/>        &quot;&quot;&quot;<br/>        Authenticate to the server using a password.  The username and password<br/>        are sent over an encrypted link.<br/>    <br/>        If an ``event`` is passed in, this method will return immediately, and<br/>        the event will be triggered once authentication succeeds or fails.  On<br/>        success, `is_authenticated` will return ``True``.  On failure, you may<br/>        use `get_exception` to get more detailed error information.<br/>    <br/>        Since 1.1, if no event is passed, this method will block until the<br/>        authentication succeeds or fails.  On failure, an exception is raised.<br/>        Otherwise, the method simply returns.<br/>    <br/>        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the<br/>        default), if the server doesn&#x27;t support plain password authentication<br/>        but does support so-called &quot;keyboard-interactive&quot; mode, an attempt<br/>        will be made to authenticate using this interactive mode.  If it fails,<br/>        the normal exception will be thrown as if the attempt had never been<br/>        made.  This is useful for some recent Gentoo and Debian distributions,<br/>        which turn off plain password authentication in a misguided belief<br/>        that interactive authentication is &quot;more secure&quot;.  (It&#x27;s not.)<br/>    <br/>        If the server requires multi-step authentication (which is very rare),<br/>        this method will return a list of auth types permissible for the next<br/>        step.  Otherwise, in the normal case, an empty list is returned.<br/>    <br/>        :param str username: the username to authenticate as<br/>        :param basestring password: the password to authenticate with<br/>        :param .threading.Event event:<br/>            an event to trigger when the authentication attempt is complete<br/>            (whether it was successful or not)<br/>        :param bool fallback:<br/>            ``True`` if an attempt at an automated &quot;interactive&quot; password auth<br/>            should be made if the server doesn&#x27;t support normal password auth<br/>        :return:<br/>            list of auth types permissible for the next stage of<br/>            authentication (normally empty)<br/>    <br/>        :raises:<br/>            `.BadAuthenticationType` -- if password authentication isn&#x27;t<br/>            allowed by the server for this user (and no event was passed in)<br/>        :raises:<br/>            `.AuthenticationException` -- if the authentication failed (and no<br/>            event was passed in)<br/>        :raises: `.SSHException` -- if there was a network error<br/>        &quot;&quot;&quot;<br/>        if (not self.active) or (not self.initial_kex_done):<br/>            # we should never try to send the password unless we&#x27;re on a secure<br/>            # link<br/>            raise SSHException(&quot;No existing session&quot;)<br/>        if event is None:<br/>            my_event = threading.Event()<br/>        else:<br/>            my_event = event<br/>        self.auth_handler = AuthHandler(self)<br/>        self.auth_handler.auth_password(username, password, my_event)<br/>        if event is not None:<br/>            # caller wants to wait for event themselves<br/>            return []<br/>        try:<br/>&gt;           return self.auth_handler.wait_for_response(my_event)<br/><br/>../../.local/lib/python3.6/site-packages/paramiko/transport.py:1564: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.auth_handler.AuthHandler object at 0x7f5cb73ae8d0&gt;<br/>event = &lt;threading.Event object at 0x7f5cb73aef98&gt;<br/><br/>    def wait_for_response(self, event):<br/>        max_ts = None<br/>        if self.transport.auth_timeout is not None:<br/>            max_ts = time.time() + self.transport.auth_timeout<br/>        while True:<br/>            event.wait(0.1)<br/>            if not self.transport.is_active():<br/>                e = self.transport.get_exception()<br/>                if (e is None) or issubclass(e.__class__, EOFError):<br/>                    e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>                raise e<br/>            if event.is_set():<br/>                break<br/>            if max_ts is not None and max_ts &lt;= time.time():<br/>                raise AuthenticationException(&quot;Authentication timeout.&quot;)<br/>    <br/>        if not self.is_authenticated():<br/>            e = self.transport.get_exception()<br/>            if e is None:<br/>                e = AuthenticationException(&quot;Authentication failed.&quot;)<br/>            # this is horrible.  Python Exception isn&#x27;t yet descended from<br/>            # object, so type(e) won&#x27;t work. :(<br/>            if issubclass(e.__class__, PartialAuthentication):<br/>                return e.allowed_types<br/>&gt;           raise e<br/><span class="error">E           paramiko.ssh_exception.AuthenticationException: Authentication failed.</span><br/><br/>../../.local/lib/python3.6/site-packages/paramiko/auth_handler.py:259: AuthenticationException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>test_importlib = &lt;module &#x27;testbed&#x27; from &#x27;/home/alexander/ONLP_Automation/tmp/testbed.py&#x27;&gt;<br/><br/>    @pytest.mark.All<br/>    @pytest.mark.Sanity<br/>    def test_CheckPSUType(test_importlib):<br/>    <br/>        DUTInfo = test_importlib<br/>&gt;       val = Get_PSU_Value(DUTInfo.DUT1_IP, 1, &#x27;Type&#x27;)<br/><br/>../Scripts/test_22.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>../Lib/GetKeyValue.py:29: in Get_PSU_Value<br/>    DUT = Login(IPAddress, &#x27;root&#x27;, &#x27;onl&#x27;)<br/>../Lib/ssh_login.py:10: in __init__<br/>    self.__deviceConnect()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ssh_login.Login object at 0x7f5cb621d320&gt;<br/><br/>    def __deviceConnect(self):<br/>        try:<br/>            self.client = paramiko.SSHClient()<br/>            self.client.load_system_host_keys()<br/>            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>            self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)<br/>&gt;       except AuthenticationException as err:<br/><span class="error">E       NameError: name &#x27;AuthenticationException&#x27; is not defined</span><br/><br/>../Lib/ssh_login.py:18: NameError<br/></div></td></tr></tbody></table></body></html>