{"name": "test_CheckPSUStatus[testbed]", "status": "broken", "statusDetails": {"message": "NameError: name 'AuthenticationException' is not defined", "trace": "self = <ssh_login.Login object at 0x7ffaac523ef0>\n\n    def __deviceConnect(self):\n        try:\n            self.client = paramiko.SSHClient()\n            self.client.load_system_host_keys()\n            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n>           self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)\n\n../Lib/ssh_login.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.client.SSHClient object at 0x7ffaac523e80>\nhostname = '192.168.1.7', port = 22, username = 'admin', password = 'onl'\npkey = None, key_filename = None, timeout = None, allow_agent = False\nlook_for_keys = False, compress = False\nsock = <socket.socket fd=12, family=AddressFamily.AF_INET, type=2049, proto=0, laddr=('172.17.238.53', 38830), raddr=('192.168.1.7', 22)>\ngss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None\nbanner_timeout = None, auth_timeout = None, gss_trust_dns = True\npassphrase = None, disabled_algorithms = None\n\n    def connect(\n        self,\n        hostname,\n        port=SSH_PORT,\n        username=None,\n        password=None,\n        pkey=None,\n        key_filename=None,\n        timeout=None,\n        allow_agent=True,\n        look_for_keys=True,\n        compress=False,\n        sock=None,\n        gss_auth=False,\n        gss_kex=False,\n        gss_deleg_creds=True,\n        gss_host=None,\n        banner_timeout=None,\n        auth_timeout=None,\n        gss_trust_dns=True,\n        passphrase=None,\n        disabled_algorithms=None,\n    ):\n        \"\"\"\n        Connect to an SSH server and authenticate to it.  The server's host key\n        is checked against the system host keys (see `load_system_host_keys`)\n        and any local host keys (`load_host_keys`).  If the server's hostname\n        is not found in either set of host keys, the missing host key policy\n        is used (see `set_missing_host_key_policy`).  The default policy is\n        to reject the key and raise an `.SSHException`.\n    \n        Authentication is attempted in the following order of priority:\n    \n            - The ``pkey`` or ``key_filename`` passed in (if any)\n    \n              - ``key_filename`` may contain OpenSSH public certificate paths\n                as well as regular private-key paths; when files ending in\n                ``-cert.pub`` are found, they are assumed to match a private\n                key, and both components will be loaded. (The private key\n                itself does *not* need to be listed in ``key_filename`` for\n                this to occur - *just* the certificate.)\n    \n            - Any key we can find through an SSH agent\n            - Any \"id_rsa\", \"id_dsa\" or \"id_ecdsa\" key discoverable in\n              ``~/.ssh/``\n    \n              - When OpenSSH-style public certificates exist that match an\n                existing such private key (so e.g. one has ``id_rsa`` and\n                ``id_rsa-cert.pub``) the certificate will be loaded alongside\n                the private key and used for authentication.\n    \n            - Plain username/password auth, if a password was given\n    \n        If a private key requires a password to unlock it, and a password is\n        passed in, that password will be used to attempt to unlock the key.\n    \n        :param str hostname: the server to connect to\n        :param int port: the server port to connect to\n        :param str username:\n            the username to authenticate as (defaults to the current local\n            username)\n        :param str password:\n            Used for password authentication; is also used for private key\n            decryption if ``passphrase`` is not given.\n        :param str passphrase:\n            Used for decrypting private keys.\n        :param .PKey pkey: an optional private key to use for authentication\n        :param str key_filename:\n            the filename, or list of filenames, of optional private key(s)\n            and/or certs to try for authentication\n        :param float timeout:\n            an optional timeout (in seconds) for the TCP connect\n        :param bool allow_agent:\n            set to False to disable connecting to the SSH agent\n        :param bool look_for_keys:\n            set to False to disable searching for discoverable private key\n            files in ``~/.ssh/``\n        :param bool compress: set to True to turn on compression\n        :param socket sock:\n            an open socket or socket-like object (such as a `.Channel`) to use\n            for communication to the target host\n        :param bool gss_auth:\n            ``True`` if you want to use GSS-API authentication\n        :param bool gss_kex:\n            Perform GSS-API Key Exchange and user authentication\n        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not\n        :param str gss_host:\n            The targets name in the kerberos database. default: hostname\n        :param bool gss_trust_dns:\n            Indicates whether or not the DNS is trusted to securely\n            canonicalize the name of the host being connected to (default\n            ``True``).\n        :param float banner_timeout: an optional timeout (in seconds) to wait\n            for the SSH banner to be presented.\n        :param float auth_timeout: an optional timeout (in seconds) to wait for\n            an authentication response.\n        :param dict disabled_algorithms:\n            an optional dict passed directly to `.Transport` and its keyword\n            argument of the same name.\n    \n        :raises:\n            `.BadHostKeyException` -- if the server's host key could not be\n            verified\n        :raises: `.AuthenticationException` -- if authentication failed\n        :raises:\n            `.SSHException` -- if there was any other error connecting or\n            establishing an SSH session\n        :raises socket.error: if a socket error occurred while connecting\n    \n        .. versionchanged:: 1.15\n            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,\n            ``gss_deleg_creds`` and ``gss_host`` arguments.\n        .. versionchanged:: 2.3\n            Added the ``gss_trust_dns`` argument.\n        .. versionchanged:: 2.4\n            Added the ``passphrase`` argument.\n        .. versionchanged:: 2.6\n            Added the ``disabled_algorithms`` argument.\n        \"\"\"\n        if not sock:\n            errors = {}\n            # Try multiple possible address families (e.g. IPv4 vs IPv6)\n            to_try = list(self._families_and_addresses(hostname, port))\n            for af, addr in to_try:\n                try:\n                    sock = socket.socket(af, socket.SOCK_STREAM)\n                    if timeout is not None:\n                        try:\n                            sock.settimeout(timeout)\n                        except:\n                            pass\n                    retry_on_signal(lambda: sock.connect(addr))\n                    # Break out of the loop on success\n                    break\n                except socket.error as e:\n                    # Raise anything that isn't a straight up connection error\n                    # (such as a resolution error)\n                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):\n                        raise\n                    # Capture anything else so we know how the run looks once\n                    # iteration is complete. Retain info about which attempt\n                    # this was.\n                    errors[addr] = e\n    \n            # Make sure we explode usefully if no address family attempts\n            # succeeded. We've no way of knowing which error is the \"right\"\n            # one, so we construct a hybrid exception containing all the real\n            # ones, of a subclass that client code should still be watching for\n            # (socket.error)\n            if len(errors) == len(to_try):\n                raise NoValidConnectionsError(errors)\n    \n        t = self._transport = Transport(\n            sock,\n            gss_kex=gss_kex,\n            gss_deleg_creds=gss_deleg_creds,\n            disabled_algorithms=disabled_algorithms,\n        )\n        t.use_compression(compress=compress)\n        t.set_gss_host(\n            # t.hostname may be None, but GSS-API requires a target name.\n            # Therefore use hostname as fallback.\n            gss_host=gss_host or hostname,\n            trust_dns=gss_trust_dns,\n            gssapi_requested=gss_auth or gss_kex,\n        )\n        if self._log_channel is not None:\n            t.set_log_channel(self._log_channel)\n        if banner_timeout is not None:\n            t.banner_timeout = banner_timeout\n        if auth_timeout is not None:\n            t.auth_timeout = auth_timeout\n    \n        if port == SSH_PORT:\n            server_hostkey_name = hostname\n        else:\n            server_hostkey_name = \"[{}]:{}\".format(hostname, port)\n        our_server_keys = None\n    \n        our_server_keys = self._system_host_keys.get(server_hostkey_name)\n        if our_server_keys is None:\n            our_server_keys = self._host_keys.get(server_hostkey_name)\n        if our_server_keys is not None:\n            keytype = our_server_keys.keys()[0]\n            sec_opts = t.get_security_options()\n            other_types = [x for x in sec_opts.key_types if x != keytype]\n            sec_opts.key_types = [keytype] + other_types\n    \n        t.start_client(timeout=timeout)\n    \n        # If GSS-API Key Exchange is performed we are not required to check the\n        # host key, because the host is authenticated via GSS-API / SSPI as\n        # well as our client.\n        if not self._transport.gss_kex_used:\n            server_key = t.get_remote_server_key()\n            if our_server_keys is None:\n                # will raise exception if the key is rejected\n                self._policy.missing_host_key(\n                    self, server_hostkey_name, server_key\n                )\n            else:\n                our_key = our_server_keys.get(server_key.get_name())\n                if our_key != server_key:\n                    if our_key is None:\n                        our_key = list(our_server_keys.values())[0]\n                    raise BadHostKeyException(hostname, server_key, our_key)\n    \n        if username is None:\n            username = getpass.getuser()\n    \n        if key_filename is None:\n            key_filenames = []\n        elif isinstance(key_filename, string_types):\n            key_filenames = [key_filename]\n        else:\n            key_filenames = key_filename\n    \n        self._auth(\n            username,\n            password,\n            pkey,\n            key_filenames,\n            allow_agent,\n            look_for_keys,\n            gss_auth,\n            gss_kex,\n            gss_deleg_creds,\n            t.gss_host,\n>           passphrase,\n        )\n\n../../.local/lib/python3.6/site-packages/paramiko/client.py:446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.client.SSHClient object at 0x7ffaac523e80>, username = 'admin'\npassword = 'onl', pkey = None, key_filenames = [], allow_agent = False\nlook_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True\ngss_host = None, passphrase = 'onl'\n\n    def _auth(\n        self,\n        username,\n        password,\n        pkey,\n        key_filenames,\n        allow_agent,\n        look_for_keys,\n        gss_auth,\n        gss_kex,\n        gss_deleg_creds,\n        gss_host,\n        passphrase,\n    ):\n        \"\"\"\n        Try, in order:\n    \n            - The key(s) passed in, if one was passed in.\n            - Any key we can find through an SSH agent (if allowed).\n            - Any \"id_rsa\", \"id_dsa\" or \"id_ecdsa\" key discoverable in ~/.ssh/\n              (if allowed).\n            - Plain username/password auth, if a password was given.\n    \n        (The password might be needed to unlock a private key [if 'passphrase'\n        isn't also given], or for two-factor authentication [for which it is\n        required].)\n        \"\"\"\n        saved_exception = None\n        two_factor = False\n        allowed_types = set()\n        two_factor_types = {\"keyboard-interactive\", \"password\"}\n        if passphrase is None and password is not None:\n            passphrase = password\n    \n        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt\n        # authentication with gssapi-keyex.\n        if gss_kex and self._transport.gss_kex_used:\n            try:\n                self._transport.auth_gssapi_keyex(username)\n                return\n            except Exception as e:\n                saved_exception = e\n    \n        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key\n        # Exchange is not performed, because if we use GSS-API for the key\n        # exchange, there is already a fully established GSS-API context, so\n        # why should we do that again?\n        if gss_auth:\n            try:\n                return self._transport.auth_gssapi_with_mic(\n                    username, gss_host, gss_deleg_creds\n                )\n            except Exception as e:\n                saved_exception = e\n    \n        if pkey is not None:\n            try:\n                self._log(\n                    DEBUG,\n                    \"Trying SSH key {}\".format(\n                        hexlify(pkey.get_fingerprint())\n                    ),\n                )\n                allowed_types = set(\n                    self._transport.auth_publickey(username, pkey)\n                )\n                two_factor = allowed_types & two_factor_types\n                if not two_factor:\n                    return\n            except SSHException as e:\n                saved_exception = e\n    \n        if not two_factor:\n            for key_filename in key_filenames:\n                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):\n                    try:\n                        key = self._key_from_filepath(\n                            key_filename, pkey_class, passphrase\n                        )\n                        allowed_types = set(\n                            self._transport.auth_publickey(username, key)\n                        )\n                        two_factor = allowed_types & two_factor_types\n                        if not two_factor:\n                            return\n                        break\n                    except SSHException as e:\n                        saved_exception = e\n    \n        if not two_factor and allow_agent:\n            if self._agent is None:\n                self._agent = Agent()\n    \n            for key in self._agent.get_keys():\n                try:\n                    id_ = hexlify(key.get_fingerprint())\n                    self._log(DEBUG, \"Trying SSH agent key {}\".format(id_))\n                    # for 2-factor auth a successfully auth'd key password\n                    # will return an allowed 2fac auth method\n                    allowed_types = set(\n                        self._transport.auth_publickey(username, key)\n                    )\n                    two_factor = allowed_types & two_factor_types\n                    if not two_factor:\n                        return\n                    break\n                except SSHException as e:\n                    saved_exception = e\n    \n        if not two_factor:\n            keyfiles = []\n    \n            for keytype, name in [\n                (RSAKey, \"rsa\"),\n                (DSSKey, \"dsa\"),\n                (ECDSAKey, \"ecdsa\"),\n                (Ed25519Key, \"ed25519\"),\n            ]:\n                # ~/ssh/ is for windows\n                for directory in [\".ssh\", \"ssh\"]:\n                    full_path = os.path.expanduser(\n                        \"~/{}/id_{}\".format(directory, name)\n                    )\n                    if os.path.isfile(full_path):\n                        # TODO: only do this append if below did not run\n                        keyfiles.append((keytype, full_path))\n                        if os.path.isfile(full_path + \"-cert.pub\"):\n                            keyfiles.append((keytype, full_path + \"-cert.pub\"))\n    \n            if not look_for_keys:\n                keyfiles = []\n    \n            for pkey_class, filename in keyfiles:\n                try:\n                    key = self._key_from_filepath(\n                        filename, pkey_class, passphrase\n                    )\n                    # for 2-factor auth a successfully auth'd key will result\n                    # in ['password']\n                    allowed_types = set(\n                        self._transport.auth_publickey(username, key)\n                    )\n                    two_factor = allowed_types & two_factor_types\n                    if not two_factor:\n                        return\n                    break\n                except (SSHException, IOError) as e:\n                    saved_exception = e\n    \n        if password is not None:\n            try:\n                self._transport.auth_password(username, password)\n                return\n            except SSHException as e:\n                saved_exception = e\n        elif two_factor:\n            try:\n                self._transport.auth_interactive_dumb(username)\n                return\n            except SSHException as e:\n                saved_exception = e\n    \n        # if we got an auth-failed exception earlier, re-raise it\n        if saved_exception is not None:\n>           raise saved_exception\n\n../../.local/lib/python3.6/site-packages/paramiko/client.py:766: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.client.SSHClient object at 0x7ffaac523e80>, username = 'admin'\npassword = 'onl', pkey = None, key_filenames = [], allow_agent = False\nlook_for_keys = False, gss_auth = False, gss_kex = False, gss_deleg_creds = True\ngss_host = None, passphrase = 'onl'\n\n    def _auth(\n        self,\n        username,\n        password,\n        pkey,\n        key_filenames,\n        allow_agent,\n        look_for_keys,\n        gss_auth,\n        gss_kex,\n        gss_deleg_creds,\n        gss_host,\n        passphrase,\n    ):\n        \"\"\"\n        Try, in order:\n    \n            - The key(s) passed in, if one was passed in.\n            - Any key we can find through an SSH agent (if allowed).\n            - Any \"id_rsa\", \"id_dsa\" or \"id_ecdsa\" key discoverable in ~/.ssh/\n              (if allowed).\n            - Plain username/password auth, if a password was given.\n    \n        (The password might be needed to unlock a private key [if 'passphrase'\n        isn't also given], or for two-factor authentication [for which it is\n        required].)\n        \"\"\"\n        saved_exception = None\n        two_factor = False\n        allowed_types = set()\n        two_factor_types = {\"keyboard-interactive\", \"password\"}\n        if passphrase is None and password is not None:\n            passphrase = password\n    \n        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt\n        # authentication with gssapi-keyex.\n        if gss_kex and self._transport.gss_kex_used:\n            try:\n                self._transport.auth_gssapi_keyex(username)\n                return\n            except Exception as e:\n                saved_exception = e\n    \n        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key\n        # Exchange is not performed, because if we use GSS-API for the key\n        # exchange, there is already a fully established GSS-API context, so\n        # why should we do that again?\n        if gss_auth:\n            try:\n                return self._transport.auth_gssapi_with_mic(\n                    username, gss_host, gss_deleg_creds\n                )\n            except Exception as e:\n                saved_exception = e\n    \n        if pkey is not None:\n            try:\n                self._log(\n                    DEBUG,\n                    \"Trying SSH key {}\".format(\n                        hexlify(pkey.get_fingerprint())\n                    ),\n                )\n                allowed_types = set(\n                    self._transport.auth_publickey(username, pkey)\n                )\n                two_factor = allowed_types & two_factor_types\n                if not two_factor:\n                    return\n            except SSHException as e:\n                saved_exception = e\n    \n        if not two_factor:\n            for key_filename in key_filenames:\n                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):\n                    try:\n                        key = self._key_from_filepath(\n                            key_filename, pkey_class, passphrase\n                        )\n                        allowed_types = set(\n                            self._transport.auth_publickey(username, key)\n                        )\n                        two_factor = allowed_types & two_factor_types\n                        if not two_factor:\n                            return\n                        break\n                    except SSHException as e:\n                        saved_exception = e\n    \n        if not two_factor and allow_agent:\n            if self._agent is None:\n                self._agent = Agent()\n    \n            for key in self._agent.get_keys():\n                try:\n                    id_ = hexlify(key.get_fingerprint())\n                    self._log(DEBUG, \"Trying SSH agent key {}\".format(id_))\n                    # for 2-factor auth a successfully auth'd key password\n                    # will return an allowed 2fac auth method\n                    allowed_types = set(\n                        self._transport.auth_publickey(username, key)\n                    )\n                    two_factor = allowed_types & two_factor_types\n                    if not two_factor:\n                        return\n                    break\n                except SSHException as e:\n                    saved_exception = e\n    \n        if not two_factor:\n            keyfiles = []\n    \n            for keytype, name in [\n                (RSAKey, \"rsa\"),\n                (DSSKey, \"dsa\"),\n                (ECDSAKey, \"ecdsa\"),\n                (Ed25519Key, \"ed25519\"),\n            ]:\n                # ~/ssh/ is for windows\n                for directory in [\".ssh\", \"ssh\"]:\n                    full_path = os.path.expanduser(\n                        \"~/{}/id_{}\".format(directory, name)\n                    )\n                    if os.path.isfile(full_path):\n                        # TODO: only do this append if below did not run\n                        keyfiles.append((keytype, full_path))\n                        if os.path.isfile(full_path + \"-cert.pub\"):\n                            keyfiles.append((keytype, full_path + \"-cert.pub\"))\n    \n            if not look_for_keys:\n                keyfiles = []\n    \n            for pkey_class, filename in keyfiles:\n                try:\n                    key = self._key_from_filepath(\n                        filename, pkey_class, passphrase\n                    )\n                    # for 2-factor auth a successfully auth'd key will result\n                    # in ['password']\n                    allowed_types = set(\n                        self._transport.auth_publickey(username, key)\n                    )\n                    two_factor = allowed_types & two_factor_types\n                    if not two_factor:\n                        return\n                    break\n                except (SSHException, IOError) as e:\n                    saved_exception = e\n    \n        if password is not None:\n            try:\n>               self._transport.auth_password(username, password)\n\n../../.local/lib/python3.6/site-packages/paramiko/client.py:753: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.Transport at 0xac523f28 (cipher aes128-ctr, 128 bits) (connected; awaiting auth)>\nusername = 'admin', password = 'onl', event = None, fallback = True\n\n    def auth_password(self, username, password, event=None, fallback=True):\n        \"\"\"\n        Authenticate to the server using a password.  The username and password\n        are sent over an encrypted link.\n    \n        If an ``event`` is passed in, this method will return immediately, and\n        the event will be triggered once authentication succeeds or fails.  On\n        success, `is_authenticated` will return ``True``.  On failure, you may\n        use `get_exception` to get more detailed error information.\n    \n        Since 1.1, if no event is passed, this method will block until the\n        authentication succeeds or fails.  On failure, an exception is raised.\n        Otherwise, the method simply returns.\n    \n        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the\n        default), if the server doesn't support plain password authentication\n        but does support so-called \"keyboard-interactive\" mode, an attempt\n        will be made to authenticate using this interactive mode.  If it fails,\n        the normal exception will be thrown as if the attempt had never been\n        made.  This is useful for some recent Gentoo and Debian distributions,\n        which turn off plain password authentication in a misguided belief\n        that interactive authentication is \"more secure\".  (It's not.)\n    \n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n    \n        :param str username: the username to authenticate as\n        :param basestring password: the password to authenticate with\n        :param .threading.Event event:\n            an event to trigger when the authentication attempt is complete\n            (whether it was successful or not)\n        :param bool fallback:\n            ``True`` if an attempt at an automated \"interactive\" password auth\n            should be made if the server doesn't support normal password auth\n        :return:\n            list of auth types permissible for the next stage of\n            authentication (normally empty)\n    \n        :raises:\n            `.BadAuthenticationType` -- if password authentication isn't\n            allowed by the server for this user (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to send the password unless we're on a secure\n            # link\n            raise SSHException(\"No existing session\")\n        if event is None:\n            my_event = threading.Event()\n        else:\n            my_event = event\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_password(username, password, my_event)\n        if event is not None:\n            # caller wants to wait for event themselves\n            return []\n        try:\n>           return self.auth_handler.wait_for_response(my_event)\n\n../../.local/lib/python3.6/site-packages/paramiko/transport.py:1564: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.auth_handler.AuthHandler object at 0x7ffaac4b3940>\nevent = <threading.Event object at 0x7ffaad5a7f28>\n\n    def wait_for_response(self, event):\n        max_ts = None\n        if self.transport.auth_timeout is not None:\n            max_ts = time.time() + self.transport.auth_timeout\n        while True:\n            event.wait(0.1)\n            if not self.transport.is_active():\n                e = self.transport.get_exception()\n                if (e is None) or issubclass(e.__class__, EOFError):\n                    e = AuthenticationException(\"Authentication failed.\")\n                raise e\n            if event.is_set():\n                break\n            if max_ts is not None and max_ts <= time.time():\n                raise AuthenticationException(\"Authentication timeout.\")\n    \n        if not self.is_authenticated():\n            e = self.transport.get_exception()\n            if e is None:\n                e = AuthenticationException(\"Authentication failed.\")\n            # this is horrible.  Python Exception isn't yet descended from\n            # object, so type(e) won't work. :(\n            if issubclass(e.__class__, PartialAuthentication):\n                return e.allowed_types\n>           raise e\nE           paramiko.ssh_exception.AuthenticationException: Authentication failed.\n\n../../.local/lib/python3.6/site-packages/paramiko/auth_handler.py:259: AuthenticationException\n\nDuring handling of the above exception, another exception occurred:\n\ntest_importlib = <module 'testbed' from '/home/alexander/ONLP_Automation/tmp/testbed.py'>\n\n    @pytest.mark.All\n    @pytest.mark.Sanity\n    def test_CheckPSUStatus(test_importlib):\n    \n        DUTInfo = test_importlib\n>       val = Get_PSU_Value(DUTInfo.DUT1_IP, 1, 'Status')\n\n../Scripts/test_20.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../Lib/GetKeyValue.py:29: in Get_PSU_Value\n    DUT = Login(IPAddress, 'admin', 'onl', 'onl')\n../Lib/ssh_login.py:11: in __init__\n    self.__deviceConnect()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssh_login.Login object at 0x7ffaac523ef0>\n\n    def __deviceConnect(self):\n        try:\n            self.client = paramiko.SSHClient()\n            self.client.load_system_host_keys()\n            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            self.client.connect(hostname=self.ipaddress, username=self.username, password=self.password, look_for_keys=False, allow_agent=False)\n>       except AuthenticationException as err:\nE       NameError: name 'AuthenticationException' is not defined\n\n../Lib/ssh_login.py:19: NameError"}, "parameters": [{"name": "filename", "value": "'testbed'"}], "start": 1661513088952, "stop": 1661513089020, "uuid": "ee8c549b-39df-44a9-bb96-13f95d3534ec", "historyId": "58e65e3755ad4003e5b06600eee60a02", "testCaseId": "2c67417aef514e1024b8c01e338110cd", "fullName": "test_20#test_CheckPSUStatus", "labels": [{"name": "tag", "value": "Sanity"}, {"name": "tag", "value": "All"}, {"name": "suite", "value": "test_20"}, {"name": "host", "value": "alexander-Virtual-Machine"}, {"name": "thread", "value": "5452-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_20"}]}